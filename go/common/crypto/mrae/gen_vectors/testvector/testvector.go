// Package testvector contains routines for workign with the test vector
// output generated by gen_vectors.
package testvector

import (
	"crypto/cipher"
	"encoding/json"
	"io/ioutil"

	"github.com/stretchr/testify/require"
)

// KnownAnswerTests is the test metadata and test vector array.
type KnownAnswerTests struct {
	Name         string
	Key          []byte
	Nonce        []byte
	MsgData      []byte
	AADData      []byte
	KnownAnswers []*TestVector
}

// TestVector is a single test result.
type TestVector struct {
	Ciphertext []byte
	Tag        []byte
	Length     int
}

// KATInputs returns the message and AAD used as inputs to the KAT tests.
func KATInputs() (msg, aad []byte) {
	msg = make([]byte, 256)
	aad = make([]byte, 256)

	for i := range msg {
		msg[i] = byte(255 & (i*197 + 123))
	}
	for i := range aad {
		aad[i] = byte(255 & (i*193 + 123))
	}

	return
}

// ValidateKATs validates the Known Answer Tests.
func ValidateKATs(a *require.Assertions, fn string, ctorFn func([]byte) (cipher.AEAD, error)) {
	raw, err := ioutil.ReadFile(fn) //nolint:gosec
	a.NoError(err, "Load test vectors")

	var kats KnownAnswerTests
	err = json.Unmarshal(raw, &kats)
	a.NoError(err, "Parse test vectors")

	nonce := kats.Nonce
	aead, err := ctorFn(kats.Key)
	a.NoError(err, "New()")
	tagLength := aead.Overhead()

	msg, aad := kats.MsgData, kats.AADData

	for _, v := range kats.KnownAnswers {
		ptLen := v.Length
		ct := aead.Seal(
			nil,
			nonce,
			msg[:ptLen],
			aad[:ptLen],
		)
		a.Len(ct, ptLen+tagLength, "[%d]: len(ciphertext | tag)", ptLen)

		tag := ct[ptLen:]
		ct = ct[:ptLen]

		a.EqualValues(v.Ciphertext, ct, "[%d]: ciphertext", ptLen)
		a.EqualValues(v.Tag, tag, "[%d]: tag", ptLen)
	}
}
