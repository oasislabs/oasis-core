defaults: &defaults
  docker:
    - image: ekiden/testing:0.2.0

version: 2
jobs:
  build-rust:
    <<: *defaults
    resource_class: large
    steps:
      # Set up
      - run: echo 'PS1='"'"'\$ '"'"'; . /root/.bashrc' >> $BASH_ENV
      - run: echo 'export SGX_MODE=SIM' >> $BASH_ENV
      - run: echo 'export INTEL_SGX_SDK=/opt/sgxsdk' >> $BASH_ENV
      - run: echo 'export EKIDEN_UNSAFE_SKIP_AVR_VERIFY=1' >> $BASH_ENV

      - checkout
      - run:
          name: Checking if rust code has changed
          command: ./scripts/ci-changed.sh \.circleci beacon clients common compute contract contracts core db di enclave epochtime instrumentation keys node registry rpc roothash scheduler scripts/test-e2e.sh stake storage tools xargo

      # Check if all core crates have the same version (issue #175)
      - run:
          name: Checking if all Ekiden crates have the same version
          command: test `find . -name "Cargo.toml" -print0 | xargs -0 grep '^version = "' | cut -d'"' -f2 | sort | uniq | wc -l` == 1

      # Install ekiden-tools.
      - run: cargo install --force --path tools
      # Build token contract.
      - run:
          command: cargo ekiden build-enclave --output-identity
          working_directory: contracts/token
      # Run token contract tests.
      - run: cargo test -p token
      # Ensure everything is built. Building an enclave needs to happen first
      - run: cargo build
      # Check style. This needs to be after everything is built.
      - run: cargo fmt -- --write-mode=check

      # Cargo tests, with the exception of some enclave-specific ones.
      - run: |
          cargo test --all \
            --exclude ekiden-untrusted \
            --exclude ekiden-enclave-untrusted \
            --exclude ekiden-rpc-untrusted \
            --exclude ekiden-db-untrusted \
            --exclude ekiden-contract-untrusted \
            --exclude ekiden-keymanager-untrusted \
            --exclude ekiden-keymanager-node \
            --exclude ekiden-keymanager-trusted \
            --exclude token \
            -- \
            --test-threads 1

      # Integration tests.
      - restore_cache:
          keys:
            - go-cache
      - run: make -C go
      - save_cache:
          key: go-cache
          paths:
            - "/go/pkg"
      - run: ./scripts/test-e2e.sh

      # Store built files.
      - persist_to_workspace:
          root: .
          paths:
            - go/ekiden/ekiden
            - target/debug/ekiden-compute
            - target/debug/token-client
            - target/debug/test-long-term-client
            - target/enclave/token.so
            - target/enclave/token.mrenclave
            - tests
            - scripts
  cover-rust:
    <<: *defaults
    resource_class: xlarge
    steps:
      - run: echo 'PS1='"'"'\$ '"'"'; . /root/.bashrc' >> $BASH_ENV
      - run: echo 'export SGX_MODE=SIM' >> $BASH_ENV
      - run: echo 'export INTEL_SGX_SDK=/opt/sgxsdk' >> $BASH_ENV
      - run: echo 'export EKIDEN_UNSAFE_SKIP_AVR_VERIFY=1' >> $BASH_ENV
      - checkout
      - run: cargo build
      # install & tarpaulin test.
      - run:
          name: Installing Tarpaulin
          command: git clone https://github.com/xd009642/tarpaulin && cd tarpaulin && git checkout tags/0.6.5 && rm Cargo.lock && sed -i 's/proc-macro2 = "/proc-macro2 = "=/' Cargo.toml && cargo install
          working_directory: /root/
      - run:
          cargo tarpaulin --all \
            --ignore-tests \
            --out Xml \
            --exclude-files *generated* \
            --exclude ekiden-untrusted \
            --exclude ekiden-enclave-untrusted \
            --exclude ekiden-rpc-untrusted \
            --exclude ekiden-db-trusted \
            --exclude ekiden-db-untrusted \
            --exclude ekiden-contract-untrusted \
            --exclude ekiden-keymanager-untrusted \
            --exclude ekiden-keymanager-node \
            --exclude ekiden-keymanager-trusted \
            --exclude token \
            --coveralls $COVERALLS_REPO_TOKEN \
            -v
      # Store coverage report.
      - persist_to_workspace:
          root: .
          paths:
            - cobertura.xml

  build-go:
    working_directory: /go/src/github.com/oasislabs/ekiden
    docker:
      - image: circleci/golang:1.11
    steps:
      - checkout
      - run:
          name: Checking if go code has changed
          command: ./scripts/ci-changed.sh \.circleci docker go
      - restore_cache:
          keys:
            - go-cache
      - run: |
          wget 'https://github.com/google/protobuf/releases/download/v3.5.1/protoc-3.5.1-linux-x86_64.zip' && \
          sudo unzip protoc-3.5.1-linux-x86_64.zip -x readme.txt -d /usr && \
          rm protoc-3.5.1-linux-x86_64.zip && \
          sudo chmod a+rx /usr/bin/protoc
      - run: |
          go get -d github.com/golang/protobuf/protoc-gen-go && \
          cd $GOPATH/src/github.com/golang/protobuf && \
          git checkout v1.0.0 && \
          cd protoc-gen-go && \
          go install
      - run: |
          curl -sfL https://install.goreleaser.com/github.com/golangci/golangci-lint.sh | bash -s -- -b /tmp/bin v1.10.1
      - run: cd go && dep ensure -v
      - run: cd go && go generate ./...
      - run: cd go && /tmp/bin/golangci-lint run
      - run: cd go && go build -v -o ./ekiden/ekiden ./ekiden
      - run: cd go && go test -race -coverprofile=coverage.txt -covermode=atomic -v ./...
      - run: bash <(curl -s https://codecov.io/bash) -Z
      - save_cache:
          key: go-cache
          paths:
            - "/go/pkg"

  lint-git:
    docker:
      - image: circleci/python:3.6.6
    steps:
      - checkout
      - run: sudo pip install gitlint
      # Lint Git commit messages.
      - run: gitlint --commits origin/master...HEAD

  benchmark:
    <<: *defaults
    resource_class: large
    steps:
      # Set up
      - run: echo 'PS1='"'"'\$ '"'"'; . /root/.bashrc' >> $BASH_ENV
      - run: echo 'export SGX_MODE=SIM' >> $BASH_ENV
      - run: echo 'export INTEL_SGX_SDK=/opt/sgxsdk' >> $BASH_ENV
      - run: echo 'export EKIDEN_UNSAFE_SKIP_AVR_VERIFY=1' >> $BASH_ENV
      - checkout

      # Build everything in release mode for benchmarks.
      - run: cargo build --release
      # Install ekiden-tools.
      - run: CARGO_TARGET_DIR=target cargo install --force --path tools
      # Build token contract.
      - run:
          command: cargo ekiden build-enclave --release --output-identity
          working_directory: contracts/token

      # Build Go parts.
      - restore_cache:
          keys:
            - go-cache
      - run: make -C go
      - save_cache:
          key: go-cache
          paths:
            - "/go/pkg"

      # Run all benchmarks.
      - run: |
          ./scripts/benchmark.py \
              --crate ekiden-rpc-trusted \
              --crate ekiden-db-trusted \
              --e2e \
              --commit $(git rev-parse --short HEAD)

  set-docker-tag:
    <<: *defaults
    steps:
      # Setup version tracking environment variables
      - checkout
      - run:
          name: Load docker tag versioning into environment
          command: ./scripts/determine-build-versioning.sh /tmp/build_image_tag

      # Save docker tag
      - persist_to_workspace:
          root: /tmp
          paths:
            - build_image_tag

  deploy:
    <<: *defaults
    resource_class: large
    steps:
      # Set up
      - run: echo 'PS1='"'"'\$ '"'"'; . /root/.bashrc' >> $BASH_ENV
      - run: echo 'export SGX_MODE=SIM' >> $BASH_ENV
      - run: echo 'export INTEL_SGX_SDK=/opt/sgxsdk' >> $BASH_ENV
      - run: echo 'export EKIDEN_UNSAFE_SKIP_AVR_VERIFY=1' >> $BASH_ENV
      - checkout

      - attach_workspace:
          at: /workspace
      - setup_remote_docker

      - run:
          name: Load current docker tag
          command: echo 'BUILD_IMAGE_TAG=`cat /workspace/build_image_tag`' >> $BASH_ENV

      # Build deployment image.
      - run: BUILD_IMAGES_NO_ENTER=1 ./docker/deployment/build-images.sh
      # Push deployment image.
      - run: |
          echo "$DOCKERHUB_PASSWORD" | docker login --username "$DOCKERHUB_USERNAME" --password-stdin
          docker push oasislabs/testnet:$BUILD_IMAGE_TAG

  promote-to-production:
    <<: *defaults
    resource_class: large
    steps:
      - checkout
      - run: echo 'export PRODUCTION_TAG=latest' >> $BASH_ENV
      - setup_remote_docker
      - attach_workspace:
          at: /workspace

      - run:
          name: Load current docker tag
          command: echo 'BUILD_IMAGE_TAG=`cat /workspace/build_image_tag`' >> $BASH_ENV

      # Login to docker
      - run: |
          echo "$DOCKERHUB_PASSWORD" | docker login --username "$DOCKERHUB_USERNAME" --password-stdin

      - run:
          name: Download the tag of ekiden for this current workflow
          command: docker pull oasislabs/testnet:$BUILD_IMAGE_TAG

      - run:
          name: Tag the ekiden build on this workflow for production
          command: docker tag oasislabs/testnet:$BUILD_IMAGE_TAG oasislabs/testnet:$PRODUCTION_TAG

      - run:
          name: Push the new production tag of ekiden to dockerhub
          command: docker push oasislabs/testnet:$PRODUCTION_TAG

workflows:
  version: 2
  build:
    jobs:
      - build-go
      - build-rust
      - lint-git
      - set-docker-tag:
          # FIXME: The master filter for this and the deploy steps is a
          # temporary measure. We want to be able to deploy feature tags to any
          # given testnet eventually. However it currently disrupts some
          # builds.
          filters:
            branches:
              only: master
      - deploy:
          filters:
            branches:
              only: master
          requires:
            - set-docker-tag
            - build-rust
            - build-go
      - hold-for-production:
          type: approval
          filters:
            branches:
              only: master
          requires:
            - deploy
      - promote-to-production:
          requires:
            - hold-for-production


  benchmark:
    jobs:
      - benchmark:
          filters:
            branches:
              only: master
  nightly:
    triggers:
      - schedule:
          cron: "0 0 * * *"
          filters:
            branches:
              only:
                - master
    jobs:
      - cover-rust
experimental:
  notify:
    branches:
      only:
        - master
